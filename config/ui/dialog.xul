<dialog id="dialog" title=" 排兵布阵_字符画" buttons="accept,cancel">
	<content>
		<grid>
			<columns id="columns">
				<column flex="1"/>
				<column flex="2"/>
			</columns>
			<rows id="controls">
				<row template="menulist">
					<label value="bug : " width="100"/>
					<menulist class="control" id="bug" editable="" width="180" flex="1" tabindex="" oncreate="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'create', 'bug');" onsetfocus="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'setfocus', 'bug');" onchange="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'change', 'bug');">
						<menupop class="control" id="menupop">
							<menuitem label="只能tab选中,第一个无法被鼠标选中," value="bug" selected="true"/>
							<menuitem label="function copyWithin(target, start) {&#xA;		var o = ES.ToObject(this);&#xA;		var len = ES.ToLength(o.length);&#xA;		var relativeTarget = ES.ToInteger(target);&#xA;		var relativeStart = ES.ToInteger(start);&#xA;		var to = relativeTarget &lt; 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);&#xA;		var from = relativeStart &lt; 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var relativeEnd = typeof end === &quot;undefined&quot; ? len : ES.ToInteger(end);&#xA;		var finalItem = relativeEnd &lt; 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);&#xA;		var count = _min(finalItem - from, len - to);&#xA;		var direction = 1;&#xA;		if (from &lt; to &amp;&amp; to &lt; from + count) {&#xA;				direction = -1;&#xA;				from += count - 1;&#xA;				to += count - 1;&#xA;		}&#xA;		while (count > 0) {&#xA;				if (from in o) {&#xA;						o[to] = o[from];&#xA;				} else {&#xA;						delete o[to];&#xA;				}&#xA;				from += direction;&#xA;				to += direction;&#xA;				count -= 1;&#xA;		}&#xA;		return o;&#xA;}" value="function copyWithin(target, start) {&#xA;		var o = ES.ToObject(this);&#xA;		var len = ES.ToLength(o.length);&#xA;		var relativeTarget = ES.ToInteger(target);&#xA;		var relativeStart = ES.ToInteger(start);&#xA;		var to = relativeTarget &lt; 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);&#xA;		var from = relativeStart &lt; 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var relativeEnd = typeof end === &quot;undefined&quot; ? len : ES.ToInteger(end);&#xA;		var finalItem = relativeEnd &lt; 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);&#xA;		var count = _min(finalItem - from, len - to);&#xA;		var direction = 1;&#xA;		if (from &lt; to &amp;&amp; to &lt; from + count) {&#xA;				direction = -1;&#xA;				from += count - 1;&#xA;				to += count - 1;&#xA;		}&#xA;		while (count > 0) {&#xA;				if (from in o) {&#xA;						o[to] = o[from];&#xA;				} else {&#xA;						delete o[to];&#xA;				}&#xA;				from += direction;&#xA;				to += direction;&#xA;				count -= 1;&#xA;		}&#xA;		return o;&#xA;}"/>
							<menuitem label="function fill(value) {&#xA;		var start;&#xA;		if (arguments.length > 1) {&#xA;				start = arguments[1];&#xA;		}&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var len = ES.ToLength(O.length);&#xA;		start = ES.ToInteger(typeof start === &quot;undefined&quot; ? 0 : start);&#xA;		end = ES.ToInteger(typeof end === &quot;undefined&quot; ? len : end);&#xA;		var relativeStart = start &lt; 0 ? _max(len + start, 0) : _min(start, len);&#xA;		var relativeEnd = end &lt; 0 ? len + end : end;&#xA;		for (var i = relativeStart; i &lt; len &amp;&amp; i &lt; relativeEnd; ++i) {&#xA;				O[i] = value;&#xA;		}&#xA;		return O;&#xA;}" value="function fill(value) {&#xA;		var start;&#xA;		if (arguments.length > 1) {&#xA;				start = arguments[1];&#xA;		}&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var len = ES.ToLength(O.length);&#xA;		start = ES.ToInteger(typeof start === &quot;undefined&quot; ? 0 : start);&#xA;		end = ES.ToInteger(typeof end === &quot;undefined&quot; ? len : end);&#xA;		var relativeStart = start &lt; 0 ? _max(len + start, 0) : _min(start, len);&#xA;		var relativeEnd = end &lt; 0 ? len + end : end;&#xA;		for (var i = relativeStart; i &lt; len &amp;&amp; i &lt; relativeEnd; ++i) {&#xA;				O[i] = value;&#xA;		}&#xA;		return O;&#xA;}"/>
							<menuitem label="function find(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#find: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0, value; i &lt; length; i++) {&#xA;				value = list[i];&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, value, i, list)) {&#xA;								return value;&#xA;						}&#xA;				} else if (predicate(value, i, list)) {&#xA;						return value;&#xA;				}&#xA;		}&#xA;}" value="function find(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#find: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0, value; i &lt; length; i++) {&#xA;				value = list[i];&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, value, i, list)) {&#xA;								return value;&#xA;						}&#xA;				} else if (predicate(value, i, list)) {&#xA;						return value;&#xA;				}&#xA;		}&#xA;}"/>
							<menuitem label="function findIndex(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#findIndex: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0; i &lt; length; i++) {&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, list[i], i, list)) {&#xA;								return i;&#xA;						}&#xA;				} else if (predicate(list[i], i, list)) {&#xA;						return i;&#xA;				}&#xA;		}&#xA;		return -1;&#xA;}" value="function findIndex(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#findIndex: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0; i &lt; length; i++) {&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, list[i], i, list)) {&#xA;								return i;&#xA;						}&#xA;				} else if (predicate(list[i], i, list)) {&#xA;						return i;&#xA;				}&#xA;		}&#xA;		return -1;&#xA;}"/>
							<menuitem label="function keys() {&#xA;		return new ArrayIterator(this, &quot;key&quot;);&#xA;}" value="function keys() {&#xA;		return new ArrayIterator(this, &quot;key&quot;);&#xA;}"/>
							<menuitem label="function values() {&#xA;		return new ArrayIterator(this, &quot;value&quot;);&#xA;}" value="function values() {&#xA;		return new ArrayIterator(this, &quot;value&quot;);&#xA;}"/>
							<menuitem label="function entries() {&#xA;		return new ArrayIterator(this, &quot;entry&quot;);&#xA;}" value="function entries() {&#xA;		return new ArrayIterator(this, &quot;entry&quot;);&#xA;}"/>
							<menuitem label="function () {&#xA;		return this.values();&#xA;}" value="function () {&#xA;		return this.values();&#xA;}"/>
							<menuitem label="function includes(searchElement) {&#xA;		var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;&#xA;		if (indexOf &amp;&amp;&#xA;				!$isNaN(searchElement) &amp;&amp;&#xA;				$isFinite(fromIndex) &amp;&amp; typeof searchElement !== &quot;undefined&quot;) {&#xA;				return indexOf.apply(this, arguments) > -1;&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var length = ES.ToLength(O.length);&#xA;		if (length === 0) {&#xA;				return false;&#xA;		}&#xA;		var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);&#xA;		while (k &lt; length) {&#xA;				if (ES.SameValueZero(searchElement, O[k])) {&#xA;						return true;&#xA;				}&#xA;				k += 1;&#xA;		}&#xA;		return false;&#xA;}" value="function includes(searchElement) {&#xA;		var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;&#xA;		if (indexOf &amp;&amp;&#xA;				!$isNaN(searchElement) &amp;&amp;&#xA;				$isFinite(fromIndex) &amp;&amp; typeof searchElement !== &quot;undefined&quot;) {&#xA;				return indexOf.apply(this, arguments) > -1;&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var length = ES.ToLength(O.length);&#xA;		if (length === 0) {&#xA;				return false;&#xA;		}&#xA;		var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);&#xA;		while (k &lt; length) {&#xA;				if (ES.SameValueZero(searchElement, O[k])) {&#xA;						return true;&#xA;				}&#xA;				k += 1;&#xA;		}&#xA;		return false;&#xA;}"/>
						</menupop>
					</menulist>
				</row>
				<row template="menulist">
					<label value="选择字符画 : " width="100"/>
					<menulist class="control" id="ascii-art-menu" editable="" width="180" flex="1" tabindex="" oncreate="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'create', 'ascii-art-menu');" onsetfocus="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'setfocus', 'ascii-art-menu');" onchange="if(window.xjsfl)xjsfl.ui.handleEvent('0', 'change', 'ascii-art-menu');">
						<menupop class="control" id="menupop">
							<menuitem label="一万人" value="file:///F|/04_ps/沙雕动画/_素材库/WindowSWF-master/WindowSWF-master/AnJsflScript/lib/20.日常脚本/XUL/排兵布阵_字符画/ascii_art_library/一万人.txt" selected="true"/>
							<menuitem label="function copyWithin(target, start) {&#xA;		var o = ES.ToObject(this);&#xA;		var len = ES.ToLength(o.length);&#xA;		var relativeTarget = ES.ToInteger(target);&#xA;		var relativeStart = ES.ToInteger(start);&#xA;		var to = relativeTarget &lt; 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);&#xA;		var from = relativeStart &lt; 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var relativeEnd = typeof end === &quot;undefined&quot; ? len : ES.ToInteger(end);&#xA;		var finalItem = relativeEnd &lt; 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);&#xA;		var count = _min(finalItem - from, len - to);&#xA;		var direction = 1;&#xA;		if (from &lt; to &amp;&amp; to &lt; from + count) {&#xA;				direction = -1;&#xA;				from += count - 1;&#xA;				to += count - 1;&#xA;		}&#xA;		while (count > 0) {&#xA;				if (from in o) {&#xA;						o[to] = o[from];&#xA;				} else {&#xA;						delete o[to];&#xA;				}&#xA;				from += direction;&#xA;				to += direction;&#xA;				count -= 1;&#xA;		}&#xA;		return o;&#xA;}" value="function copyWithin(target, start) {&#xA;		var o = ES.ToObject(this);&#xA;		var len = ES.ToLength(o.length);&#xA;		var relativeTarget = ES.ToInteger(target);&#xA;		var relativeStart = ES.ToInteger(start);&#xA;		var to = relativeTarget &lt; 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);&#xA;		var from = relativeStart &lt; 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var relativeEnd = typeof end === &quot;undefined&quot; ? len : ES.ToInteger(end);&#xA;		var finalItem = relativeEnd &lt; 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);&#xA;		var count = _min(finalItem - from, len - to);&#xA;		var direction = 1;&#xA;		if (from &lt; to &amp;&amp; to &lt; from + count) {&#xA;				direction = -1;&#xA;				from += count - 1;&#xA;				to += count - 1;&#xA;		}&#xA;		while (count > 0) {&#xA;				if (from in o) {&#xA;						o[to] = o[from];&#xA;				} else {&#xA;						delete o[to];&#xA;				}&#xA;				from += direction;&#xA;				to += direction;&#xA;				count -= 1;&#xA;		}&#xA;		return o;&#xA;}"/>
							<menuitem label="function fill(value) {&#xA;		var start;&#xA;		if (arguments.length > 1) {&#xA;				start = arguments[1];&#xA;		}&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var len = ES.ToLength(O.length);&#xA;		start = ES.ToInteger(typeof start === &quot;undefined&quot; ? 0 : start);&#xA;		end = ES.ToInteger(typeof end === &quot;undefined&quot; ? len : end);&#xA;		var relativeStart = start &lt; 0 ? _max(len + start, 0) : _min(start, len);&#xA;		var relativeEnd = end &lt; 0 ? len + end : end;&#xA;		for (var i = relativeStart; i &lt; len &amp;&amp; i &lt; relativeEnd; ++i) {&#xA;				O[i] = value;&#xA;		}&#xA;		return O;&#xA;}" value="function fill(value) {&#xA;		var start;&#xA;		if (arguments.length > 1) {&#xA;				start = arguments[1];&#xA;		}&#xA;		var end;&#xA;		if (arguments.length > 2) {&#xA;				end = arguments[2];&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var len = ES.ToLength(O.length);&#xA;		start = ES.ToInteger(typeof start === &quot;undefined&quot; ? 0 : start);&#xA;		end = ES.ToInteger(typeof end === &quot;undefined&quot; ? len : end);&#xA;		var relativeStart = start &lt; 0 ? _max(len + start, 0) : _min(start, len);&#xA;		var relativeEnd = end &lt; 0 ? len + end : end;&#xA;		for (var i = relativeStart; i &lt; len &amp;&amp; i &lt; relativeEnd; ++i) {&#xA;				O[i] = value;&#xA;		}&#xA;		return O;&#xA;}"/>
							<menuitem label="function find(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#find: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0, value; i &lt; length; i++) {&#xA;				value = list[i];&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, value, i, list)) {&#xA;								return value;&#xA;						}&#xA;				} else if (predicate(value, i, list)) {&#xA;						return value;&#xA;				}&#xA;		}&#xA;}" value="function find(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#find: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0, value; i &lt; length; i++) {&#xA;				value = list[i];&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, value, i, list)) {&#xA;								return value;&#xA;						}&#xA;				} else if (predicate(value, i, list)) {&#xA;						return value;&#xA;				}&#xA;		}&#xA;}"/>
							<menuitem label="function findIndex(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#findIndex: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0; i &lt; length; i++) {&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, list[i], i, list)) {&#xA;								return i;&#xA;						}&#xA;				} else if (predicate(list[i], i, list)) {&#xA;						return i;&#xA;				}&#xA;		}&#xA;		return -1;&#xA;}" value="function findIndex(predicate) {&#xA;		var list = ES.ToObject(this);&#xA;		var length = ES.ToLength(list.length);&#xA;		if (!ES.IsCallable(predicate)) {&#xA;				throw new TypeError(&quot;Array#findIndex: predicate must be a function&quot;);&#xA;		}&#xA;		var thisArg = arguments.length > 1 ? arguments[1] : null;&#xA;		for (var i = 0; i &lt; length; i++) {&#xA;				if (thisArg) {&#xA;						if (_call(predicate, thisArg, list[i], i, list)) {&#xA;								return i;&#xA;						}&#xA;				} else if (predicate(list[i], i, list)) {&#xA;						return i;&#xA;				}&#xA;		}&#xA;		return -1;&#xA;}"/>
							<menuitem label="function keys() {&#xA;		return new ArrayIterator(this, &quot;key&quot;);&#xA;}" value="function keys() {&#xA;		return new ArrayIterator(this, &quot;key&quot;);&#xA;}"/>
							<menuitem label="function values() {&#xA;		return new ArrayIterator(this, &quot;value&quot;);&#xA;}" value="function values() {&#xA;		return new ArrayIterator(this, &quot;value&quot;);&#xA;}"/>
							<menuitem label="function entries() {&#xA;		return new ArrayIterator(this, &quot;entry&quot;);&#xA;}" value="function entries() {&#xA;		return new ArrayIterator(this, &quot;entry&quot;);&#xA;}"/>
							<menuitem label="function () {&#xA;		return this.values();&#xA;}" value="function () {&#xA;		return this.values();&#xA;}"/>
							<menuitem label="function includes(searchElement) {&#xA;		var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;&#xA;		if (indexOf &amp;&amp;&#xA;				!$isNaN(searchElement) &amp;&amp;&#xA;				$isFinite(fromIndex) &amp;&amp; typeof searchElement !== &quot;undefined&quot;) {&#xA;				return indexOf.apply(this, arguments) > -1;&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var length = ES.ToLength(O.length);&#xA;		if (length === 0) {&#xA;				return false;&#xA;		}&#xA;		var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);&#xA;		while (k &lt; length) {&#xA;				if (ES.SameValueZero(searchElement, O[k])) {&#xA;						return true;&#xA;				}&#xA;				k += 1;&#xA;		}&#xA;		return false;&#xA;}" value="function includes(searchElement) {&#xA;		var fromIndex = arguments.length > 1 ? ES.ToInteger(arguments[1]) : 0;&#xA;		if (indexOf &amp;&amp;&#xA;				!$isNaN(searchElement) &amp;&amp;&#xA;				$isFinite(fromIndex) &amp;&amp; typeof searchElement !== &quot;undefined&quot;) {&#xA;				return indexOf.apply(this, arguments) > -1;&#xA;		}&#xA;		var O = ES.ToObject(this);&#xA;		var length = ES.ToLength(O.length);&#xA;		if (length === 0) {&#xA;				return false;&#xA;		}&#xA;		var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);&#xA;		while (k &lt; length) {&#xA;				if (ES.SameValueZero(searchElement, O[k])) {&#xA;						return true;&#xA;				}&#xA;				k += 1;&#xA;		}&#xA;		return false;&#xA;}"/>
						</menupop>
					</menulist>
				</row>
			</rows>
		</grid>
	</content>
	<script>if(window.xjsfl)
			{
				xjsfl.ui.handleEvent(0, 'initialize');
			}</script>
	<property id="xulid" value="0"/>
</dialog>