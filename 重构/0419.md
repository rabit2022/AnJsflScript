frutil.jsfl

好的，以下是重构后的模块划分以及每个模块包含的函数：

### 1. **`FrameRangeUtil` 模块**
**功能描述**：处理与帧范围相关的操作。
- **`wrapFrFromSl(selectedFrames)`**：将选中帧数组转换为帧范围数组。
- **`getSelectedFrs(timeline)`**：获取时间线中选中的帧范围。
- **`resetSelectedFrames(timeline, frs)`**：根据帧范围数组重置时间线的选中帧。
SelectStartFms


KeyFrameChecker
- **`IsKeyFrame(layer, frameIndex)`**：检查指定帧是否为关键帧。

KeyFrameQuery
- **`getKeyFrames(layer)`**：获取图层中的关键帧索引数组。
- **`wrapKeyFrames(layers, layer, keyFrames)`**：根据关键帧索引数组生成关键帧范围数组。
- **`getKeyFrameRanges(layers, curLayer)`**：获取当前图层的关键帧范围数组。
- **`getKfrFromSlLittle(selectedFrLittle, keyFrameRanges)`**：从关键帧范围数组中找到包含特定选中范围的关键帧范围。

KeyFrameOperation
- **`convertToKeyframesSafety(timeline, keyFramesIndex, [selectedLayer])`**：安全地将指定帧转换为关键帧（避免重复转换）。
- **`convertToKeyframesAtFirstSelected`**：k帧





### 6. **模块命名与职责**
- **`FrameRangeUtil`**：专注于帧范围的操作。
- **`KeyFrameUtil`**：专注于关键帧的操作。

通过这种模块划分，代码的职责更加清晰，每个模块只负责一个功能，便于维护和扩展。



理解你的需求，我们可以进一步简化模块名称，使其更简洁且易于理解。以下是优化后的模块划分和命名：

### 优化后的模块划分

#### 1. **`ElementChecker` 模块**
**功能描述**：提供对元素类型的检查功能。
- **`IsGroup(element)`**：判断是否是组。
- **`IsSymbol(element)`**：判断是否是元件。
- **`IsBitmap(element)`**：判断是否是位图。
- **`IsShape(element, strict)`**：判断是否是形状。
- **`IsDrawingObject(element)`**：判断是否是绘制对象。

#### 2. **`ElementQuery` 模块**
**功能描述**：提供对元素属性的操作功能。
- **`getName(element)`**：获取元素的名称。
- **`getMaxRight(elements)`**：获取最右边的元素。

#### 3. **`ElementOperation` 模块**
**功能描述**：提供对元素的操作功能，包括复制、打散、分割等。
- **`CopySymbol(element, mode, newName)`**：复制元件。
- **`breakApartToShape(element)`**：将元素完全打散为形状。
- **`breakApartToDrawingObject(element)`**：将元素完全打散为绘制对象。
- **`splinterSymbol(element, SymbolName)`**：将元件分割成多个碎片。

#### 4. **`ElementTransform` 模块**
**功能描述**：提供对元素变形点和注册点的操作功能。
- **`resetRegisterPoint(element)`**：重置注册点（已标记为废弃）。
- **`setTransformationPoint(element, whichCorner)`**：更改元件的变形点。

#### 5. **`ElementAnim` 模块**
**功能描述**：提供对元素动画的操作功能。
- **`playOnce(elements)`**：播放一次动画。

### 模块职责总结
- **`ElementChecker`**：专注于元素类型的检查。
- **`ElementProperty`**：专注于元素属性的获取。
- **`ElementEditor`**：专注于对元素的操作，如复制、打散、分割等。
- **`ElementTransform`**：专注于元素变形点和注册点的操作。
- **`ElementAnimation`**：专注于元素的动画操作。

### 优势
这种命名方式更加简洁明了，模块名称更短且易于记忆。同时，模块的职责划分依然清晰，便于维护和扩展。






理解你的问题。`query` 和 `checker` 的区别主要在于它们的侧重点：

- **`checker`** 通常用于验证和检查某些条件是否满足，例如是否存在、是否符合某种类型等。它的输出通常是布尔值（`true` 或 `false`）。
- **`query`** 则更侧重于检索和获取数据，例如获取满足条件的列表、获取某个属性的值等。

在 `LayerUtil` 的上下文中，`checker` 可能更适合用于判断图层是否存在，而 `query` 更适合用于获取图层或图层索引。

### 更好的划分建议
我们可以将 `LayerUtil` 模块划分为以下两个模块：

#### 1. **`LayerChecker` 模块**
**功能描述**：提供对图层的检查功能。
- **`IsLayerExists(layers, layerName)`**：判断图层是否存在。

#### 2. **`LayerQuery` 模块**
**功能描述**：提供对图层的查询功能。
- **`getLayersByName(layers, layerName)`**：获取包含指定名称的图层。
- **`getLayersIndexByName(layers, layerName)`**：获取包含指定名称的图层的索引。
- **`convertToLayerIndex(layers, layer)`**：将图层或图层索引转换为图层索引。
- **`convertToLayer(layers, layer)`**：将图层索引转换为图层。

#### 3. **`LayerOperation` 模块**
**功能描述**：提供对图层的操作功能。
- **`deleteLayers(timeline, layers)`**：删除图层。
- **`swapLayers(timeline, layerIndex1, layerIndex2)`**：交换图层。

### 模块职责总结
- **`LayerChecker`**：专注于图层的检查，例如是否存在。
- **`LayerQuery`**：专注于图层的查询，例如获取图层或图层索引。
- **`LayerOperation`**：专注于图层的操作，例如删除和交换。

### 优势
这种划分方式更加清晰，每个模块的职责更加明确，且模块名称简洁明了，易于理解和使用。






理解你的需求，如果函数较多且功能复杂，可以进一步优化模块划分，将功能相关的函数归类到不同的模块中。对于 `Curve` 模块，我们可以根据功能的性质将其划分为以下几个模块：

### 重构后的模块划分

#### 1. **`EaseCurveUtil` 模块**
**功能描述**：提供缓动曲线的设置和操作功能。
- **`setEaseCurve(timeline, easeCurve)`**：设置缓动曲线。
- **`setClassicEaseCurve(timeline, easeInOut, intensity)`**：设置经典缓动曲线。

#### 2. **`TweenUtil` 模块**
**功能描述**：提供缓动的创建和删除功能。
- **`createTween(timeline, tweenType)`**：创建缓动。
- **`deleteMotionTween(timeline, startFrame, endFrame)`**：删除缓动。
- **`createTweenIntelligent(frame)`**：创建智能缓动。
- **`setTweenRotation(timeline, motionTweenRotate, motionTweenRotateTimes)`**：设置旋转缓动。

### 模块职责总结
- **`EaseCurveUtil`**：专注于缓动曲线的设置和操作。
- **`TweenUtil`**：专注于缓动的创建和删除。





tryload改为tips，
提醒全局变量不能在局部重新定义


function checkVariableRedeclaration(...args) {
    // 获取函数调用的上下文
    const caller = arguments.callee.caller;
    const outerScope = Object.getOwnPropertyNames(caller);

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        const argName = Object.keys(arg)[0]; // 获取参数名称
        const argValue = arg[argName]; // 获取参数值

        // 检查参数是否在函数外部已经定义
        if (outerScope.includes(argName)) {
            if (argValue === undefined) {
                console.warn(`警告：参数 ${argName} 在函数内被重新声明为 undefined，可能覆盖了外部变量。`);
            } else {
                throw new Error(`错误：参数 ${argName} 已经在函数外部定义，不能在函数内重新声明。`);
            }
        }
    }
}

// 示例使用
var timeline = 'externalValue';

try {
    checkVariableRedeclaration({ timeline: undefined }); // 警告：参数 timeline 在函数内被重新声明为 undefined，可能覆盖了外部变量。
    checkVariableRedeclaration({ timeline: 'newValue' }); // 错误：参数 timeline 已经在函数外部定义，不能在函数内重新声明。
} catch (e) {
    console.error(e.message);
}




